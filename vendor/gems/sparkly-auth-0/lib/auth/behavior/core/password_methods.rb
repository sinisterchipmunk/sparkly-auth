module Auth::Behavior::Core::PasswordMethods
  def self.included(base)
    # so apparently dynamic methods haven't been generated by AR yet, so this stuff's been moved to
    # #after_initialize. Less than ideal but whatever.
#    base.send(:alias_method_chain, :secret=, :encryption)
#    base.send(:alias_method_chain, :secret_confirmation=, :encryption)
  end
  
  def after_initialize
    # FIXME: HACK - see self.included(base)
    
    if attributes.keys.include?('secret')
      self.secret # uh, makes AR define the method, I guess? This feels clunky...
    end
    
    class << self
      alias_method_chain :secret=, :encryption
      alias_method_chain :secret_confirmation=, :encryption
    end
  end
  
  def expired?
    authenticatable.password_expired?
  end
  
  def encrypt(p)
    self.salt ||= Auth::Token.new.to_s
    Auth.encryptor.encrypt(p, salt)
  end
  
  def matches?(phrase)
    Auth.encryptor.matches?(secret, phrase, salt)
  end
  
  def reset_persistence_token
    self.persistence_token = Auth::Token.new.to_s
  end

  def reset_single_access_token
    self.single_access_token = Auth::Token.new.to_s
  end

  def reset_perishable_token
    self.perishable_token = Auth::Token.new.to_s
  end
  
  def secret_with_encryption=(phrase)
    @unencrypted_secret = phrase
    encrypted_phrase = phrase.blank? ? phrase : encrypt(phrase)
    returning self.secret_without_encryption = encrypted_phrase do
      reset_persistence_token
      reset_single_access_token unless single_access_token # don't reset after it has a value
      reset_perishable_token
    end
  end
  
  def secret_confirmation_with_encryption=(phrase)
    encrypted_phrase = phrase.blank? ? phrase : encrypt(phrase)
    self.secret_confirmation_without_encryption = encrypted_phrase
  end
  
  def unencrypted_secret
    @unencrypted_secret
  end
end
